#!/bin/bash
# mage-dev - Unified tool for MageKnight worktree management and dev servers
#
# Usage:
#   mage-dev                    # Interactive picker (arrow keys + enter)
#   mage-dev <worktree-name>    # Opens dev server for specific worktree
#   mage-dev new <branch>       # Create worktree ‚Üí install ‚Üí build ‚Üí claude
#   mage-dev delete [branch]    # Delete a worktree
#   mage-dev list               # List worktrees with ports (non-interactive)
#   mage-dev ports              # Show running dev servers
#
# Examples:
#   mage-dev new fix-combat       # Create worktree ‚Üí build ‚Üí claude
#   mage-dev                      # Pick from menu to start dev server
#   mage-dev interesting-thompson # Start dev server directly
#   mage-dev delete               # Delete worktree (shows picker)
#
# Setup:
#   ln -s /path/to/MageKnight/scripts/mage-dev ~/bin/mage-dev

# Auto-detect the worktree base from this script's location (resolve symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
REPO_NAME="$(basename "$REPO_ROOT")"

# Default worktree location (can be overridden with MAGE_KNIGHT_WORKTREES env var)
WORKTREE_BASE="${MAGE_KNIGHT_WORKTREES:-$HOME/.claude-worktrees/$REPO_NAME}"

# Base port for dev servers (Vite default is 5173)
BASE_PORT=5173

# Generate a deterministic port from worktree name (5173-5199 range)
get_port_for_worktree() {
    local name="$1"
    # Simple hash: sum of ASCII values mod 27, then add to base port
    local hash=0
    for (( i=0; i<${#name}; i++ )); do
        hash=$((hash + $(printf '%d' "'${name:$i:1}")))
    done
    echo $((BASE_PORT + (hash % 27)))
}

# Prune stale worktrees and clean up invalid directories
cleanup_stale_worktrees() {
    # Prune git's worktree references
    git -C "$REPO_ROOT" worktree prune 2>/dev/null
    # Remove directories that aren't valid worktrees (no .git file)
    if [ -d "$WORKTREE_BASE" ]; then
        for dir in "$WORKTREE_BASE"/*/; do
            if [ -d "$dir" ] && [ ! -f "$dir/.git" ]; then
                rm -rf "$dir"
            fi
        done
    fi
}

# Get array of worktree names
get_worktrees() {
    cleanup_stale_worktrees
    local worktrees=()
    if [ -d "$WORKTREE_BASE" ]; then
        for dir in "$WORKTREE_BASE"/*/; do
            # Only include valid worktrees (have .git file)
            if [ -d "$dir" ] && [ -f "$dir/.git" ]; then
                worktrees+=("$(basename "$dir")")
            fi
        done
    fi
    echo "${worktrees[@]}"
}

# Interactive picker using arrow keys
interactive_picker() {
    local worktrees=($(get_worktrees))

    if [ ${#worktrees[@]} -eq 0 ]; then
        echo "No worktrees found in $WORKTREE_BASE"
        exit 1
    fi

    local selected=0
    local num_items=${#worktrees[@]}

    # Hide cursor
    tput civis
    trap 'tput cnorm; exit' INT TERM

    while true; do
        # Clear screen and show header
        clear
        echo "üéÆ MageKnight Dev Server"
        echo ""
        echo "‚Üë/‚Üì select  |  Enter start  |  k kill  |  q quit"
        echo ""

        # Show worktrees with selection indicator
        for i in "${!worktrees[@]}"; do
            local name="${worktrees[$i]}"
            local port=$(get_port_for_worktree "$name")
            local status=""

            # Check if already running
            if is_server_running "$name"; then
                status=" ‚óè RUNNING"
            fi

            if [ $i -eq $selected ]; then
                echo "  ‚Üí $name :$port$status"
            else
                echo "    $name :$port$status"
            fi
        done

        # Read single keypress
        read -rsn1 key

        # Handle arrow keys (they send escape sequences)
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 key
            case $key in
                '[A') # Up arrow
                    ((selected--))
                    [ $selected -lt 0 ] && selected=$((num_items - 1))
                    ;;
                '[B') # Down arrow
                    ((selected++))
                    [ $selected -ge $num_items ] && selected=0
                    ;;
            esac
        elif [[ $key == "" ]]; then  # Enter
            tput cnorm  # Show cursor
            echo ""
            start_dev_server "${worktrees[$selected]}"
            exit 0
        elif [[ $key == "k" || $key == "K" ]]; then
            # Kill the selected server if running
            local name="${worktrees[$selected]}"
            kill_dev_server "$name"
            sleep 0.3
            # Stay in picker (will refresh on next loop)
        elif [[ $key == "q" || $key == "Q" ]]; then
            tput cnorm  # Show cursor
            echo ""
            echo "Cancelled."
            exit 0
        fi
    done
}

# List all worktrees with their assigned ports (non-interactive)
list_worktrees() {
    echo "Available $REPO_NAME worktrees:"
    echo ""
    printf "  %-30s %s\n" "WORKTREE" "PORT"
    printf "  %-30s %s\n" "--------" "----"
    if [ -d "$WORKTREE_BASE" ]; then
        for dir in "$WORKTREE_BASE"/*/; do
            if [ -d "$dir" ]; then
                name=$(basename "$dir")
                port=$(get_port_for_worktree "$name")
                printf "  %-30s %s\n" "$name" "http://localhost:$port"
            fi
        done
    else
        echo "  (none found in $WORKTREE_BASE)"
    fi
    echo ""
    echo "Usage: mage-dev <worktree-name>"
}

# Show which dev servers are currently running
show_running_ports() {
    echo "Running MageKnight dev servers:"
    echo ""

    local found=false
    if [ -d "$WORKTREE_BASE" ]; then
        for dir in "$WORKTREE_BASE"/*/; do
            if [ -d "$dir" ] && [ -f "$dir/.git" ]; then
                local name
                name=$(basename "$dir")
                if is_server_running "$name"; then
                    found=true
                    local url
                    url=$(grep "Local:" "$dir/.dev-server.log" 2>/dev/null | sed 's/.*http/http/' | tr -d ' ')
                    echo "  üéÆ $name"
                    echo "     ${url:-running}"
                    echo ""
                fi
            fi
        done
    fi

    if [ "$found" = false ]; then
        echo "  (no dev servers running)"
        echo ""
    fi
}

# Start dev server for a worktree (runs in background)
start_dev_server() {
    local WORKTREE_NAME="$1"
    local WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
    local LOG_FILE="$WORKTREE_PATH/.dev-server.log"
    local PID_FILE="$WORKTREE_PATH/.dev-server.pid"

    # Check if already running
    if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
        local url
        url=$(grep "Local:" "$LOG_FILE" 2>/dev/null | sed 's/.*http/http/' | tr -d ' ')
        echo "‚ö†Ô∏è  Already running: ${url:-check logs}"
        [ -n "$url" ] && open "$url"
        return 0
    fi

    echo "üéÆ Starting dev server: $WORKTREE_NAME"

    # Start in background, save PID
    (cd "$WORKTREE_PATH" && pnpm run dev:client > "$LOG_FILE" 2>&1) &
    echo $! > "$PID_FILE"
    disown

    # Wait for "ready" in log and extract actual port
    echo "Waiting for server..."
    for i in {1..20}; do
        if grep -q "ready in" "$LOG_FILE" 2>/dev/null; then
            local url
            url=$(grep "Local:" "$LOG_FILE" | sed 's/.*http/http/' | tr -d ' ')
            echo "‚úÖ $url"
            open "$url"
            return 0
        fi
        sleep 0.5
    done

    # Check for errors
    if grep -q "ERROR\|Error\|error" "$LOG_FILE" 2>/dev/null; then
        echo "‚ùå Server failed to start:"
        grep -A2 "ERROR\|Error" "$LOG_FILE" | head -5
        echo ""
        echo "Full log: $LOG_FILE"
        rm -f "$PID_FILE"
    else
        echo "‚ö†Ô∏è  Still starting. Logs: tail -f $LOG_FILE"
    fi
}

# Kill dev server for a worktree
kill_dev_server() {
    local WORKTREE_NAME="$1"
    local WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
    local PID_FILE="$WORKTREE_PATH/.dev-server.pid"

    if [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null
            # Also kill child processes (vite)
            pkill -P "$pid" 2>/dev/null
            echo "Killed dev server for $WORKTREE_NAME"
        fi
        rm -f "$PID_FILE"
    fi
}

# Check if dev server is running for a worktree
is_server_running() {
    local WORKTREE_NAME="$1"
    local PID_FILE="$WORKTREE_BASE/$WORKTREE_NAME/.dev-server.pid"
    [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

# Create new worktree and start claude
create_worktree() {
    local branch_name="$1"

    if [ -z "$branch_name" ]; then
        echo "Usage: mage-dev new <branch-name>"
        exit 1
    fi

    cd "$REPO_ROOT" || exit 1

    # Flatten branch name for directory (replace / with -)
    local dir_name="${branch_name//\//-}"
    local worktree_path="$WORKTREE_BASE/$dir_name"

    # Check if already exists
    if [ -d "$worktree_path" ]; then
        echo "Error: Worktree already exists: $worktree_path"
        exit 1
    fi

    # Ensure base directory exists
    mkdir -p "$WORKTREE_BASE"

    echo "üéÆ Creating worktree: $branch_name"
    echo ""

    # Create the worktree (post-checkout hook handles assets)
    if ! git worktree add -b "$branch_name" "$worktree_path"; then
        echo "Error: Failed to create worktree"
        exit 1
    fi

    # Install deps and build packages (client needs built server/core/shared)
    echo ""
    echo "Running pnpm install && pnpm build..."
    (cd "$worktree_path" && pnpm install && pnpm build)

    # Start claude
    echo ""
    echo "Starting claude..."
    cd "$worktree_path" && claude --dangerously-skip-permissions
}

# Delete worktree
delete_worktree() {
    local worktree_name="$1"

    cd "$REPO_ROOT" || exit 1

    # If no name provided, show picker
    if [ -z "$worktree_name" ]; then
        local worktrees=($(get_worktrees))
        if [ ${#worktrees[@]} -eq 0 ]; then
            echo "No worktrees found in $WORKTREE_BASE"
            exit 1
        fi

        echo "Select worktree to delete:"
        echo ""
        for i in "${!worktrees[@]}"; do
            echo "  $((i+1))) ${worktrees[$i]}"
        done
        echo ""
        read -rp "Enter number (or q to quit): " choice

        if [[ "$choice" == "q" ]]; then
            echo "Cancelled."
            exit 0
        fi

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#worktrees[@]} ]; then
            echo "Invalid selection"
            exit 1
        fi

        worktree_name="${worktrees[$((choice-1))]}"
    fi

    local worktree_path="$WORKTREE_BASE/$worktree_name"

    if [ ! -d "$worktree_path" ]; then
        echo "Error: Worktree not found: $worktree_path"
        exit 1
    fi

    # Kill any running dev server
    if is_server_running "$worktree_name"; then
        echo "Stopping dev server..."
        kill_dev_server "$worktree_name"
        sleep 0.3
    fi

    echo ""
    read -rp "Delete worktree '$worktree_name' and its branch? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    echo "Removing worktree..."
    git worktree remove "$worktree_path" --force

    echo "Deleting branch..."
    git branch -D "$worktree_name" 2>/dev/null || true

    echo ""
    echo "‚úÖ Deleted: $worktree_name"
}

# Handle commands
case "$1" in
    "")
        interactive_picker
        ;;
    "new"|"create")
        create_worktree "$2"
        exit 0
        ;;
    "delete"|"rm"|"remove")
        delete_worktree "$2"
        exit 0
        ;;
    "list")
        list_worktrees
        exit 0
        ;;
    "ports"|"running")
        show_running_ports
        exit 0
        ;;
    "cleanup")
        echo "üßπ Checking for merged worktrees..."
        echo ""
        cd "$REPO_ROOT" || exit 1

        # Get list of branches merged to main (strip leading spaces, *, and + markers)
        merged_branches=$(git branch --merged main | grep -v "^\*\|main" | sed 's/^[[:space:]*+]*//')

        found=false
        for dir in "$WORKTREE_BASE"/*/; do
            if [ -d "$dir" ] && [ -f "$dir/.git" ]; then
                name=$(basename "$dir")
                # Get the branch name for this worktree
                branch=$(git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null)

                # Check if branch is merged to main
                if echo "$merged_branches" | grep -qx "$branch"; then
                    found=true
                    echo "  $name (branch: $branch) - merged to main"

                    # Kill dev server if running
                    if is_server_running "$name"; then
                        kill_dev_server "$name"
                        echo "    ‚Ü≥ Stopped dev server"
                    fi

                    read -rp "    Delete this worktree? [y/N] " confirm
                    if [[ "$confirm" =~ ^[Yy]$ ]]; then
                        git worktree remove "$dir" --force 2>/dev/null
                        git branch -d "$branch" 2>/dev/null
                        echo "    ‚Ü≥ Deleted"
                    fi
                    echo ""
                fi
            fi
        done

        if [ "$found" = false ]; then
            echo "  No merged worktrees found."
        fi
        exit 0
        ;;
    "kill"|"stop")
        if [ -z "$2" ]; then
            echo "Usage: mage-dev kill <worktree-name>"
            echo ""
            show_running_ports
            exit 1
        fi
        if is_server_running "$2"; then
            kill_dev_server "$2"
            echo "‚úÖ Stopped $2"
        else
            echo "No server running for $2"
        fi
        exit 0
        ;;
    "help"|"-h"|"--help")
        echo "mage-dev - MageKnight worktree management and dev servers"
        echo ""
        echo "Commands:"
        echo "  new <branch>        Create worktree ‚Üí install ‚Üí build ‚Üí claude"
        echo "  delete [branch]     Delete a worktree"
        echo "  cleanup             Delete worktrees merged to main"
        echo "  <worktree-name>     Start dev server (background)"
        echo "  kill <worktree>     Stop dev server"
        echo "  ports               Show running dev servers"
        echo "  list                List all worktrees"
        echo ""
        echo "Examples:"
        echo "  mage-dev new fix-combat       # Create worktree and start claude"
        echo "  mage-dev feat-challenge       # Start dev server"
        echo "  mage-dev kill feat-challenge  # Stop dev server"
        echo "  mage-dev cleanup              # Clean up merged worktrees"
        exit 0
        ;;
    *)
        WORKTREE_NAME="$1"
        WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"

        if [ ! -d "$WORKTREE_PATH" ]; then
            echo "Error: Worktree not found: $WORKTREE_PATH"
            echo ""
            list_worktrees
            exit 1
        fi

        start_dev_server "$WORKTREE_NAME"
        ;;
esac
