//! Parity tests — replay TS golden traces in the Rust engine.
//!
//! Each test loads a JSON fixture generated by `tools/generate-parity-traces.ts`,
//! replays the action sequence through `apply_legal_action()`, and asserts that
//! the Rust state matches the TS state snapshot after each step.

use std::fs;
use std::path::PathBuf;

use serde::Deserialize;

use mk_types::enums::*;
use mk_types::hex::HexCoord;
use mk_types::ids::*;
use mk_types::legal_action::LegalAction;
use mk_types::state::*;

use crate::action_pipeline::apply_legal_action;
use crate::setup::create_solo_game;
use crate::undo::UndoStack;

// =============================================================================
// Deserialization types
// =============================================================================

#[derive(Debug, Deserialize)]
struct TraceFile {
    #[allow(dead_code)]
    format_version: String,
    #[allow(dead_code)]
    scenario: String,
    seed: u32,
    hero: String,
    steps: Vec<TraceStep>,
}

#[derive(Debug, Deserialize)]
struct TraceStep {
    step: usize,
    action: Option<ActionRecord>,
    expected: StateSnapshot,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
enum ActionRecord {
    #[serde(rename = "select_tactic")]
    SelectTactic { tactic_id: String },
    #[serde(rename = "play_card_basic")]
    PlayCardBasic {
        card_id: String,
        hand_index: usize,
    },
    #[serde(rename = "play_card_powered")]
    PlayCardPowered {
        card_id: String,
        hand_index: usize,
        mana_color: String,
    },
    #[serde(rename = "play_card_sideways")]
    PlayCardSideways {
        card_id: String,
        hand_index: usize,
        sideways_as: String,
    },
    #[serde(rename = "move")]
    Move {
        target: CoordRecord,
        cost: u32,
    },
    #[serde(rename = "explore")]
    Explore { direction: String },
    #[serde(rename = "resolve_choice")]
    ResolveChoice { choice_index: usize },
    #[serde(rename = "end_turn")]
    EndTurn,
    #[serde(rename = "declare_rest")]
    DeclareRest,
    #[serde(rename = "complete_rest")]
    CompleteRest {
        discard_hand_index: Option<usize>,
    },
    #[serde(rename = "undo")]
    Undo,
}

#[derive(Debug, Deserialize)]
struct CoordRecord {
    q: i32,
    r: i32,
}

#[derive(Debug, Deserialize)]
struct StateSnapshot {
    player: PlayerSnapshot,
    game: GameSnap,
    mana_dice: Vec<DieSnapshot>,
    map_hex_count: usize,
    tile_count: usize,
}

#[derive(Debug, Deserialize)]
struct PlayerSnapshot {
    position: CoordRecord,
    hand: Vec<String>,
    deck: Vec<String>,
    discard: Vec<String>,
    play_area: Vec<String>,
    move_points: u32,
    influence_points: u32,
    healing_points: u32,
    fame: u32,
    level: u32,
    reputation: i8,
    armor: u32,
    hand_limit: u32,
    crystals: CrystalSnapshot,
    mana_token_count: usize,
    selected_tactic: Option<String>,
    flags: FlagSnapshot,
    has_pending: bool,
    pending_option_count: usize,
}

#[derive(Debug, Deserialize)]
struct CrystalSnapshot {
    red: u8,
    blue: u8,
    green: u8,
    white: u8,
}

#[derive(Debug, Deserialize)]
struct FlagSnapshot {
    has_moved: bool,
    played_card: bool,
    is_resting: bool,
    has_taken_action: bool,
}

#[derive(Debug, Deserialize)]
struct GameSnap {
    time_of_day: String,
    round: u32,
    round_phase: String,
    in_combat: bool,
}

#[derive(Debug, Deserialize)]
struct DieSnapshot {
    id: String,
    color: String,
    depleted: bool,
}

// =============================================================================
// ActionRecord → LegalAction conversion
// =============================================================================

impl ActionRecord {
    fn to_legal_action(&self) -> LegalAction {
        match self {
            ActionRecord::SelectTactic { tactic_id } => LegalAction::SelectTactic {
                tactic_id: TacticId::from(tactic_id.as_str()),
            },
            ActionRecord::PlayCardBasic {
                card_id,
                hand_index,
            } => LegalAction::PlayCardBasic {
                hand_index: *hand_index,
                card_id: CardId::from(card_id.as_str()),
            },
            ActionRecord::PlayCardPowered {
                card_id,
                hand_index,
                mana_color,
            } => LegalAction::PlayCardPowered {
                hand_index: *hand_index,
                card_id: CardId::from(card_id.as_str()),
                mana_color: parse_basic_mana_color(mana_color),
            },
            ActionRecord::PlayCardSideways {
                card_id,
                hand_index,
                sideways_as,
            } => LegalAction::PlayCardSideways {
                hand_index: *hand_index,
                card_id: CardId::from(card_id.as_str()),
                sideways_as: parse_sideways_as(sideways_as),
            },
            ActionRecord::Move { target, cost } => LegalAction::Move {
                target: HexCoord::new(target.q, target.r),
                cost: *cost,
            },
            ActionRecord::Explore { direction } => LegalAction::Explore {
                direction: parse_hex_direction(direction),
            },
            ActionRecord::ResolveChoice { choice_index } => LegalAction::ResolveChoice {
                choice_index: *choice_index,
            },
            ActionRecord::EndTurn => LegalAction::EndTurn,
            ActionRecord::DeclareRest => LegalAction::DeclareRest,
            ActionRecord::CompleteRest { discard_hand_index } => LegalAction::CompleteRest {
                discard_hand_index: *discard_hand_index,
            },
            ActionRecord::Undo => LegalAction::Undo,
        }
    }
}

fn parse_basic_mana_color(s: &str) -> BasicManaColor {
    match s {
        "red" => BasicManaColor::Red,
        "blue" => BasicManaColor::Blue,
        "green" => BasicManaColor::Green,
        "white" => BasicManaColor::White,
        _ => panic!("Unknown basic mana color: {}", s),
    }
}

fn parse_sideways_as(s: &str) -> SidewaysAs {
    match s {
        "move" => SidewaysAs::Move,
        "influence" => SidewaysAs::Influence,
        "attack" => SidewaysAs::Attack,
        "block" => SidewaysAs::Block,
        _ => panic!("Unknown sideways_as: {}", s),
    }
}

fn parse_hex_direction(s: &str) -> mk_types::hex::HexDirection {
    use mk_types::hex::HexDirection;
    match s {
        "NE" => HexDirection::NE,
        "E" => HexDirection::E,
        "SE" => HexDirection::SE,
        "SW" => HexDirection::SW,
        "W" => HexDirection::W,
        "NW" => HexDirection::NW,
        _ => panic!("Unknown hex direction: {}", s),
    }
}

fn parse_hero(s: &str) -> Hero {
    match s {
        "arythea" => Hero::Arythea,
        "tovak" => Hero::Tovak,
        "goldyx" => Hero::Goldyx,
        "norowas" => Hero::Norowas,
        "wolfhawk" => Hero::Wolfhawk,
        "krang" => Hero::Krang,
        "braevalar" => Hero::Braevalar,
        _ => panic!("Unknown hero: {}", s),
    }
}

// =============================================================================
// State assertion
// =============================================================================

fn assert_state_matches(state: &GameState, expected: &StateSnapshot, step: usize) {
    let player = &state.players[0];

    // -- Position --
    let pos = player.position.expect("Player should have a position");
    assert_eq!(
        pos.q, expected.player.position.q,
        "Step {}: position.q mismatch (got {}, want {})",
        step, pos.q, expected.player.position.q
    );
    assert_eq!(
        pos.r, expected.player.position.r,
        "Step {}: position.r mismatch (got {}, want {})",
        step, pos.r, expected.player.position.r
    );

    // -- Hand --
    let hand: Vec<&str> = player.hand.iter().map(|c| c.as_str()).collect();
    assert_eq!(
        hand, expected.player.hand,
        "Step {}: hand mismatch\n  got:  {:?}\n  want: {:?}",
        step, hand, expected.player.hand
    );

    // -- Deck --
    let deck: Vec<&str> = player.deck.iter().map(|c| c.as_str()).collect();
    assert_eq!(
        deck, expected.player.deck,
        "Step {}: deck mismatch\n  got:  {:?}\n  want: {:?}",
        step, deck, expected.player.deck
    );

    // -- Discard --
    let discard: Vec<&str> = player.discard.iter().map(|c| c.as_str()).collect();
    assert_eq!(
        discard, expected.player.discard,
        "Step {}: discard mismatch\n  got:  {:?}\n  want: {:?}",
        step, discard, expected.player.discard
    );

    // -- Play area --
    let play_area: Vec<&str> = player.play_area.iter().map(|c| c.as_str()).collect();
    assert_eq!(
        play_area, expected.player.play_area,
        "Step {}: play_area mismatch\n  got:  {:?}\n  want: {:?}",
        step, play_area, expected.player.play_area
    );

    // -- Numeric resources --
    assert_eq!(
        player.move_points, expected.player.move_points,
        "Step {}: move_points mismatch (got {}, want {})",
        step, player.move_points, expected.player.move_points
    );
    assert_eq!(
        player.influence_points, expected.player.influence_points,
        "Step {}: influence_points mismatch (got {}, want {})",
        step, player.influence_points, expected.player.influence_points
    );
    assert_eq!(
        player.healing_points, expected.player.healing_points,
        "Step {}: healing_points mismatch (got {}, want {})",
        step, player.healing_points, expected.player.healing_points
    );

    // -- Fame / Level / Reputation --
    assert_eq!(
        player.fame, expected.player.fame,
        "Step {}: fame mismatch",
        step
    );
    assert_eq!(
        player.level, expected.player.level,
        "Step {}: level mismatch",
        step
    );
    assert_eq!(
        player.reputation, expected.player.reputation,
        "Step {}: reputation mismatch",
        step
    );
    assert_eq!(
        player.armor, expected.player.armor,
        "Step {}: armor mismatch",
        step
    );
    assert_eq!(
        player.hand_limit, expected.player.hand_limit,
        "Step {}: hand_limit mismatch",
        step
    );

    // -- Crystals --
    assert_eq!(
        player.crystals.red, expected.player.crystals.red,
        "Step {}: crystals.red mismatch",
        step
    );
    assert_eq!(
        player.crystals.blue, expected.player.crystals.blue,
        "Step {}: crystals.blue mismatch",
        step
    );
    assert_eq!(
        player.crystals.green, expected.player.crystals.green,
        "Step {}: crystals.green mismatch",
        step
    );
    assert_eq!(
        player.crystals.white, expected.player.crystals.white,
        "Step {}: crystals.white mismatch",
        step
    );

    // -- Mana tokens (count only) --
    assert_eq!(
        player.pure_mana.len(),
        expected.player.mana_token_count,
        "Step {}: mana_token_count mismatch (got {}, want {})",
        step,
        player.pure_mana.len(),
        expected.player.mana_token_count
    );

    // -- Selected tactic --
    let selected_tactic = player.selected_tactic.as_ref().map(|t| t.as_str().to_string());
    assert_eq!(
        selected_tactic, expected.player.selected_tactic,
        "Step {}: selected_tactic mismatch (got {:?}, want {:?})",
        step, selected_tactic, expected.player.selected_tactic
    );

    // -- Flags --
    assert_eq!(
        player
            .flags
            .contains(PlayerFlags::HAS_MOVED_THIS_TURN),
        expected.player.flags.has_moved,
        "Step {}: flag has_moved mismatch",
        step
    );
    assert_eq!(
        player
            .flags
            .contains(PlayerFlags::PLAYED_CARD_FROM_HAND_THIS_TURN),
        expected.player.flags.played_card,
        "Step {}: flag played_card mismatch",
        step
    );
    assert_eq!(
        player.flags.contains(PlayerFlags::IS_RESTING),
        expected.player.flags.is_resting,
        "Step {}: flag is_resting mismatch",
        step
    );
    assert_eq!(
        player
            .flags
            .contains(PlayerFlags::HAS_TAKEN_ACTION_THIS_TURN),
        expected.player.flags.has_taken_action,
        "Step {}: flag has_taken_action mismatch",
        step
    );

    // -- Pending --
    let has_pending = player.pending.has_active();
    assert_eq!(
        has_pending, expected.player.has_pending,
        "Step {}: has_pending mismatch (got {}, want {})",
        step, has_pending, expected.player.has_pending
    );
    if has_pending {
        if let Some(mk_types::pending::ActivePending::Choice(ref choice)) = player.pending.active {
            assert_eq!(
                choice.options.len(),
                expected.player.pending_option_count,
                "Step {}: pending_option_count mismatch",
                step
            );
        }
    }

    // -- Game state --
    let time_of_day_str = match state.time_of_day {
        TimeOfDay::Day => "day",
        TimeOfDay::Night => "night",
    };
    assert_eq!(
        time_of_day_str, expected.game.time_of_day,
        "Step {}: time_of_day mismatch",
        step
    );
    assert_eq!(
        state.round, expected.game.round,
        "Step {}: round mismatch",
        step
    );
    let round_phase_str = match state.round_phase {
        RoundPhase::TacticsSelection => "tactics_selection",
        RoundPhase::PlayerTurns => "player_turns",
    };
    assert_eq!(
        round_phase_str, expected.game.round_phase,
        "Step {}: round_phase mismatch",
        step
    );
    assert_eq!(
        state.combat.is_some(),
        expected.game.in_combat,
        "Step {}: in_combat mismatch",
        step
    );

    // -- Mana dice --
    assert_eq!(
        state.source.dice.len(),
        expected.mana_dice.len(),
        "Step {}: dice count mismatch",
        step
    );
    for (i, (actual, exp)) in state.source.dice.iter().zip(&expected.mana_dice).enumerate() {
        assert_eq!(
            actual.id.as_str(),
            exp.id,
            "Step {}: die[{}].id mismatch",
            step,
            i
        );
        let actual_color = format!("{:?}", actual.color).to_lowercase();
        assert_eq!(
            actual_color, exp.color,
            "Step {}: die[{}].color mismatch (got {}, want {})",
            step, i, actual_color, exp.color
        );
        assert_eq!(
            actual.is_depleted, exp.depleted,
            "Step {}: die[{}].depleted mismatch",
            step, i
        );
    }

    // -- Map --
    assert_eq!(
        state.map.hexes.len(),
        expected.map_hex_count,
        "Step {}: map_hex_count mismatch",
        step
    );
    assert_eq!(
        state.map.tiles.len(),
        expected.tile_count,
        "Step {}: tile_count mismatch",
        step
    );
}

// =============================================================================
// Test runner
// =============================================================================

fn run_parity_test(fixture_name: &str) {
    let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures")
        .join(format!("{}.json", fixture_name));

    let json = fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {}: {}", path.display(), e));
    let trace: TraceFile =
        serde_json::from_str(&json).unwrap_or_else(|e| panic!("Failed to parse fixture: {}", e));

    let mut state = create_solo_game(trace.seed, parse_hero(&trace.hero));
    let mut undo_stack = UndoStack::new();

    // Step 0: verify initial state matches
    assert_state_matches(&state, &trace.steps[0].expected, 0);

    // Steps 1..N: replay actions
    for step in &trace.steps[1..] {
        let action_record = step
            .action
            .as_ref()
            .unwrap_or_else(|| panic!("Step {} has no action", step.step));
        let action = action_record.to_legal_action();
        let epoch = state.action_epoch;

        apply_legal_action(&mut state, &mut undo_stack, 0, &action, epoch).unwrap_or_else(|e| {
            panic!(
                "Step {}: apply_legal_action failed for {:?}: {:?}",
                step.step, action, e
            )
        });

        assert_state_matches(&state, &step.expected, step.step);
    }
}

// =============================================================================
// Test functions
// =============================================================================

#[test]
fn parity_basic_turn() {
    run_parity_test("basic_turn");
}

#[test]
fn parity_sideways_play() {
    run_parity_test("sideways_play");
}

#[test]
fn parity_multiple_cards() {
    run_parity_test("multiple_cards");
}
